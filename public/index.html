<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Thailand Map Data Visualisation</title>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- <script src="https://d3js.org/d3.v3.min.js"></script> -->
    <script src="https://d3js.org/d3-geo-projection.v3.min.js"></script>
    <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
    <script src="js/map.js"></script>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <style>
        #map {
            width: 960px;
            height: 700px;
        }
    </style>
</head>
<body>

 <div id="map"></div>

<svg></svg>

<h2>Welcome</h2>


<script>
    console.log(d3)

    let width = 960,
        height = 700,
        centered;


    // Promise format does not work with d3 version 3
    Promise.all([
        d3.json("thailand.json",
            console.log("This is the callback function"),
            console.log("callback2")
        ),
        d3.csv("coordinatesJan28.csv")
    ]).then( ([mapData ,coordinates]) => {
        coordBox(coordinates),
        createMap(mapData, coordinates),
            test(mapData, coordinates),
            callback()

    })


    function coordBox(coordinates) {

        console.log("min in a something: " + d3.min(coordinates, function(d) { return parseFloat(d.latitude); }));

        var minLatSoFar = coordinates[0].latitude,
            maxLatSoFar = coordinates[0].latitude,
            minLongSoFar = coordinates[0].longitude,
            maxLongSoFar = coordinates[0].longitude;

        console.log("first one " + minLatSoFar);

        var i;
        for(i = 0; i < coordinates.length; i++) {
            if(parseInt(coordinates[i].latitude) < minLatSoFar) {
                console.log("i: " + i + ": " + minLatSoFar);
                minLatSoFar = coordinates[i].latitude;
                console.log("i2: " + i + ": " + minLatSoFar);
            }
            if(parseInt(coordinates[i].latitude) > maxLatSoFar) {
                maxLatSoFar = coordinates[i].latitude;
            }
            if(parseInt(coordinates[i].longitude) < minLongSoFar) {
                minLongSoFar = coordinates[i].longitude;
            }
            if(parseInt(coordinates[i].longitude) > maxLongSoFar) {
                maxLongSoFar = coordinates[i].longitude;
            }
        }

        console.log("minLat " + minLatSoFar); // -0.824
        console.log("maxLat " + maxLatSoFar); // 9.558
        console.log("minLong " + minLongSoFar); // 100.039
        console.log("maxLong " + maxLongSoFar); // 99.995
    }

    function callback() {
        console.log("This is the callback function");
    }

    function test(mapData, coordinates) {


        var map = new L.Map("map", {center: [13.7, 100.5], zoom: 5})
            .addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));

        // Finds the overlayPane div and places 2 svgs inside. The second has a class name of "circle-layer"
        // There is also a g div in the first svg with a name of "leaflet-zoom-hide"
        var svg = d3.select(map.getPanes().overlayPane).append("svg"),
            g = svg.append("g").attr("class", "leaflet-zoom-hide"),
            svg1 = d3.select(map.getPanes().overlayPane).append("svg").attr("class", "circle-layer"),
            g1 = svg1.append("g").attr("class", "inner-CL");

        // This takes the path and fits the projection on it using the function below
        var transform = d3.geoTransform({point: projectPoint}),
            path = d3.geoPath().projection(transform);

        var feature = g.selectAll("path")
            .data(mapData.features)
            .enter().append("path");

        // Creates all the circle elements in the circle-layer div
        g1.selectAll("circle")
            .data(coordinates)
            .enter().append("circle");

        // Selector. Selects all the circle elements in the circle-layer div
        const allCircles = document.querySelectorAll(".inner-CL > circle");
        //allCircles[0].classList.add("class" + 1);
        console.log("next is selector");

        // Sets all the attributes for each circle element
        for(var i = 0; i < coordinates.length; i++) {
            if(coordinates[i].latitude > 5 && coordinates[i].latitude < 20) {
                if (coordinates[i].longitude > 98 && coordinates[i].longitude < 105) {
                    allCircles[i].classList.add("class" + i);
                    allCircles[i].setAttribute("r", 3)
                    allCircles[i].setAttribute("stroke-width", 1);
                    allCircles[i].setAttribute("stroke", "#4F442B");
                    allCircles[i].setAttribute("fill", "#FFD061");
                    allCircles[i].setAttribute("cx", map.latLngToLayerPoint(new L.LatLng(coordinates[i].latitude, coordinates[i].longitude)).x);
                    allCircles[i].setAttribute("cy", map.latLngToLayerPoint(new L.LatLng(coordinates[i].latitude, coordinates[i].longitude)).y);
                }
            }
        }

        // TODO when you zoom in too much this isnt big enought. Need to calculate and update.
        svg1.attr("width", 2000)
        .attr("height", 2000);


        // The following code adds a boundary box around all the dots in d3
        /*
        var minLatSoFar = coordinates[0].latitude,
            maxLatSoFar = coordinates[0].latitude,
            minLongSoFar = coordinates[0].longitude,
            maxLongSoFar = coordinates[0].longitude;

        var i;
        for(i = 0; i < coordinates.length; i++) {
            if(parseInt(coordinates[i].latitude) < minLatSoFar) {
                minLatSoFar = coordinates[i].latitude;
            }
            if(parseInt(coordinates[i].latitude) > maxLatSoFar) {
                maxLatSoFar = coordinates[i].latitude;
            }
            if(parseInt(coordinates[i].longitude) < minLongSoFar) {
                minLongSoFar = coordinates[i].longitude;
            }
            if(parseInt(coordinates[i].longitude) > maxLongSoFar) {
                maxLongSoFar = coordinates[i].longitude;
            }
        }

        var latlngs = [[parseFloat(minLatSoFar), parseFloat(minLongSoFar)],
            [parseFloat(maxLatSoFar), parseFloat(minLongSoFar)],
            [parseFloat(maxLatSoFar), parseFloat(maxLongSoFar)],
            [parseFloat(minLatSoFar), parseFloat(maxLongSoFar)]];

        var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
        */




        map.on("viewreset", reset);
        reset();

            // This function runs on zoom. It needs to redraw the path and dots and set the svg sizes
            function reset() {
                console.log("Starting reset");
                var bounds = path.bounds(mapData),
                    topLeft = bounds[0],
                    bottomRight = bounds[1];

                svg.attr("width", 10000)
                    .attr("height", 10000)
                    .attr("width", bottomRight[0] - topLeft[0])
                    .attr("height", bottomRight[1] - topLeft[1])
                    .style("left", topLeft[0] + "px")
                    .style("top", topLeft[1] + "px")
                    .attr("d", function (d) {
                        return path(d)
                    })
                    .attr("stroke-width", 2)
                    .attr("stroke", "blue")
                    .attr("fill", "transparent");

                // THIS IS THE STYLE FOR THE CIRCLE LAYER
                svg1.style("left", topLeft[0] + "px")
                    .style("top", topLeft[1] + "px");

                g.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

                g1.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")");

                //svg1.attr("transform", "translate(" + -topLeft[0] + "," + -topLeft[1] + ")")

                feature.attr("d", path)
                    .on("mouseover", function(d) {
                        d3.select(this).style("fill", d => "blue");
                    })
                    .on("mouseout", function(d) {
                        d3.select(this).style("fill", d => "transparent");
                    });

                const allCircles = document.querySelectorAll(".inner-CL > circle");
                for(i = 0; i < coordinates.length; i++) {
                            allCircles[i].setAttribute("cx", map.latLngToLayerPoint(new L.LatLng(coordinates[i].latitude, coordinates[i].longitude)).x);
                            allCircles[i].setAttribute("cy", map.latLngToLayerPoint(new L.LatLng(coordinates[i].latitude, coordinates[i].longitude)).y);
                }
            }


            function projectPoint(x, y) {
                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
                this.stream.point(point.x, point.y);
            }



        }





function createMap(mapData, coordinates) {

    console.log("Checkpoint 6");

    console.log(mapData)
    console.log(coordinates)

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var g = svg.append('g');
    var mapLayer = g.append('g')
        .classed('map-layer', true);

    var circleLayer = g.append('g')
        .classed('circle-layer', true);

    let proj = d3.geoMercator()
        .translate([250, 250])
        .scale(2000)
        .rotate([-100.6331, -13.2])

    let path = d3.geoPath()
        .projection(proj)

    mapLayer.selectAll("path")
        .data(mapData.features)
        .enter()
        .append("path")
            .attr("d", function(d) { return path(d) })
            .attr("stroke-width", 2)
            .attr("stroke", "#ffffff")
            .attr("fill", d => "blue");


    //THIS PUTS THE DOTS ON THE MAP
     circleLayer.selectAll("circle")
         .data(coordinates)
         .enter()
         .append("circle")
             .attr("r", 3)
             .attr("cx", d => proj([+d.longitude, +d.latitude])[0])
             .attr("cy", d => proj([+d.longitude, +d.latitude])[1])
             .attr("stroke-width", 1)
             .attr("stroke", "#4F442B")
             .attr("fill", function() { return "#FFD061" });



//    d3.csv("coordinates.csv", function(fireData) {
//        console.log(fireData)
//        console.log(proj([mapData.latitude, mapData.longitude]))
//        console.log(proj([fireData[0].latitude, fireData[0].longitude]))
//        mapLayer.selectAll("path")
//            .data(fireData)
//            .enter()
//            .append("circle")
//                .attr("r", 3)
//                .attr("cx", d => proj([d.latitude, d.longitude])[0])
//                .attr("cy", d => proj([d.latitude, d.longitude])[1])
//                .attr("stroke-width", 1)
//                .attr("stroke", "#4F442B")
//                .attr("fill", function() { return "#FFD061" });
//    });

    // d3.select("svg")
    //     .selectAll("path")
    //     .data(mapData.features)
    //     .enter()
    //     .append("path")
    //         .attr("d", path)
    //         .attr("d", function(d) { return path(d) })
    //         .attr("stroke-width", 1)
    //         .attr("stroke", "#ffffff")
    //         .style("fill", function() { return "#FFD061" });

}




</script>

</body>
</html>
